// WARNING: This file is automatically generated. Any manual modification will be removed.
#include <scene/components/materials/shaders/GLSL/460/effects/Shadows.hpp>

std::string ShadowsDirLightShadowsVertexCode =
"\
// Depth map for directional light shadows.\n\
\n\
layout(location = 0) in vec3 position ;\n\
\n\
void main() {\n\
    gl_Position = mvpMatrix * vec4(position, 1.f) ;\n\
}\n\
" ;

std::string ShadowsShadowCalculationModuleCode =
"\
layout(location = UNIFORM_SHADOW_USE_LOCATION) uniform int useShadow ;\n\
layout(location = UNIFORM_SHADOW_AMOUNT_CASCADE_LOCATION) uniform int amountCascades ;\n\
layout(location = UNIFORM_SHADOW_CASCADED_SPLITS_LOCATION) uniform float cascadedSplits[MAX_AMOUNT_SHADOW_CASCADES] ;\n\
layout(location = UNIFORM_SHADOW_CASCADE_MATRICES_LOCATION) uniform mat4 lightViewProjectionMatrices[MAX_AMOUNT_SHADOW_CASCADES] ;\n\
layout(binding = SHADOW_DEPTH_MAP_BINDING_UNIT) uniform sampler2DArrayShadow cascadedDepthTexture ;\n\
\n\
/**\n\
 * Compute the distance of the given point from the camera location.\n\
 * @param   Position to know the distance from the camera.\n\
 * @return  Distance between the given position and the camera location.\n\
 */\n\
float distanceFromCamera(vec4 position) {\n\
    vec4 projectedPosition = projectionMatrix * position ;\n\
    return projectedPosition.z / farPlaneDistance ;\n\
}\n\
\n\
/**\n\
 * Compute the shadow for the current fragment.\n\
 * @param   lightSpaceFragPosition  Position of the fragment in the light space\n\
 *                                  coordinates system. It is used to compare\n\
 *                                  the depth in the shadow depth and the one of\n\
 *                                  the current fragment from the light point of\n\
 *                                  view.\n\
 * @return  1 if the fragment is lit (not shadowed); 0 if the fragment is in the\n\
 *          shadow. It is in the shadow of the light if its depth is higher than\n\
 *          the depth taken from the light depth map.\n\
 */\n\
float ShadowCompute(\n\
    vec3 lightDirection,\n\
    vec4 position,\n\
    vec3 normal,\n\
    float depth\n\
) {\n\
    float litFragment = 1.f ;\n\
\n\
    if (useShadow == 0) {\n\
        return litFragment ;\n\
    }\n\
\n\
    const float bias = max(0.005f * (1.f - dot(normal, lightDirection)), 0.0005f) ;\n\
    float distanceCamera = distanceFromCamera(position) ;\n\
\n\
    // Select the right cascade index based on the distance of the fragment to\n\
    // the camera.\n\
    int selectedCascade = 0 ;\n\
    for (int cascadeIndex = amountCascades - 1 ; cascadeIndex >= 0 ; cascadeIndex--) {\n\
        if (distanceCamera < cascadedSplits[cascadeIndex]) {\n\
            selectedCascade = cascadeIndex ;\n\
            break ;\n\
        }\n\
    }\n\
\n\
    vec4 projectionCoordinates ;\n\
    vec4 worldPosition = inverseViewMatrix * position ;\n\
    vec4 lightSpacePosition = lightViewProjectionMatrices[selectedCascade] * worldPosition ;\n\
    projectionCoordinates.xyw = (lightSpacePosition.xyz / lightSpacePosition.w) * 0.5f + 0.5f ;\n\
    projectionCoordinates.w = projectionCoordinates.w - bias ;\n\
    projectionCoordinates.z = float(selectedCascade) ;\n\
    float shadowMapDepth = texture(cascadedDepthTexture, projectionCoordinates).r ;\n\
\n\
    float currentDepth = projectionCoordinates.w ;// - bias ;\n\
    litFragment = float(currentDepth < shadowMapDepth) ;\n\
    return litFragment ;\n\
}\n\
" ;

std::string ShadowsDirLightShadowsFragmentCode =
"\
// Depth map for directional light shadows.\n\
\n\
void main() {\n\
    //gl_FragDepth = gl_FragCoord.z ;\n\
}\n\
" ;

