// WARNING: This file is automatically generated. Any manual modification will be removed.
#include <scene/components/materials/shaders/GLSL/450/modules/Functions.hpp>

std::string FunctionsUtilityModuleCode =
"\
vec3 AdjustNormalVector(mat3 tbnMatrix, vec3 normalValue) {\n\
    vec3 adjustedNormalVector = normalize((normalValue * 2.f) - 1.f) ;\n\
    adjustedNormalVector = normalize(tbnMatrix * adjustedNormalVector) ;\n\
    return adjustedNormalVector ;\n\
}\n\
" ;

std::string FunctionsLightComputeModuleCode =
"\
/*** Data ***/\n\
struct DirectionalLight {\n\
    // Direction of the light.\n\
    vec3 direction ;\n\
\n\
    // Color of the light.\n\
    vec3 color ;\n\
\n\
    // Power of the light.\n\
    float power ;\n\
\n\
    // Does the light produce a specular?\n\
    float generateSpecular ;\n\
} ;\n\
\n\
struct PointLight {\n\
    // Position of the light in the 3D space.\n\
    vec3 position ;\n\
\n\
    // Color of the light.\n\
    vec3 color ;\n\
\n\
    // Distance of the light effect.\n\
    float falloffDistance ;\n\
\n\
    // Linear attenuation of the light.\n\
    float linearAttenuation ;\n\
\n\
    // Quadratic attenuation of the light.\n\
    float quadraticAttenuation ;\n\
\n\
    // Power of the light.\n\
    float power ;\n\
\n\
    // Does the light produce a specular?\n\
    float generateSpecular ;\n\
} ;\n\
\n\
layout (std140, binding = LIGHTS_DATA_UBO_BINDING_INDEX) uniform LightsData\n\
{\n\
    DirectionalLight dirLights[MAX_DIRECTIONAL_LIGHTS] ;\n\
    PointLight pointLights[MAX_POINT_LIGHTS] ;\n\
    int amountDirectionalLights ;\n\
    int amountPointLights ;\n\
} ;\n\
\n\
\n\
struct FragmentData {\n\
    // Position of the fragment in the world.\n\
    vec3 worldPosition ;\n\
\n\
    // Diffuse color value.\n\
    vec3 diffuseValue ;\n\
\n\
    // Normal value.\n\
    vec3 normalValue ;\n\
\n\
    // Specular color value.\n\
    vec3 specularValue ;\n\
\n\
    // Shininess value.\n\
    float shininess ;\n\
} ;\n\
\n\
/*** Functions ***/\n\
/**\n\
 * Compute the directional light contribution in a fragment shader.\n\
 * @param   light           Data of the directional light.\n\
 * @param   viewDirection   Direction of the view.\n\
 * @param   fragment        Data on the processed fragment.\n\
 * @return  Light contribution color.\n\
 */\n\
vec3 ComputeDirectionalLight(\n\
    DirectionalLight light,\n\
    vec3 viewDirection,\n\
    FragmentData fragment\n\
) {\n\
    vec3 lightDirection = -light.direction ;\n\
    lightDirection = normalize((viewMatrix * vec4(lightDirection, 0.f))).xyz ;\n\
    float lambertian = max(dot(lightDirection, fragment.normalValue), 0.0) ;\n\
    vec3 reflectDirection = reflect(-lightDirection, fragment.normalValue) ;\n\
\n\
    vec3 halfwayDirection = normalize(lightDirection + viewDirection) ;\n\
    float specularAngle = max(dot(reflectDirection, viewDirection), 0.f) ;\n\
    specularAngle *= pow(specularAngle, fragment.shininess) ;\n\
    vec3 specularColor = light.generateSpecular * light.color * specularAngle ;\n\
\n\
    vec3 lightPowerColor = light.color * light.power ;\n\
    vec3 returnedLighting = fragment.diffuseValue * lambertian * lightPowerColor ;\n\
    returnedLighting += fragment.specularValue * specularColor * lightPowerColor ;\n\
\n\
    return returnedLighting ;\n\
}\n\
\n\
/**\n\
 * Compute the point light contribution in a fragment shader.\n\
 * @param   light           Data of the point light.\n\
 * @param   viewDirection   Direction of the view.\n\
 * @param   fragment        Data on the processed fragment.\n\
 * @return  Light contribution color.\n\
 */\n\
vec3 ComputePointLight(\n\
    PointLight light,\n\
    vec3 viewDirection,\n\
    FragmentData fragment\n\
) {\n\
    vec3 lightDirection = normalize(light.position - fragment.worldPosition) ;\n\
    float lambertian = max(dot(lightDirection, fragment.normalValue), 0.0) ;\n\
    vec3 reflectDirection = reflect(-lightDirection, fragment.normalValue) ;\n\
\n\
    vec3 halfwayDirection = normalize(lightDirection + viewDirection) ;\n\
    float specularAngle = max(dot(reflectDirection, viewDirection), 0.f) ;\n\
    specularAngle *= pow(specularAngle, fragment.shininess) ;\n\
    vec3 specularColor = light.generateSpecular * light.color * specularAngle ;\n\
\n\
    float lightDistance = length(fragment.worldPosition - light.position) ;\n\
    float sqrLightDistance = lightDistance * lightDistance ;\n\
    float sqrFalloffDistance = light.falloffDistance * light.falloffDistance ;\n\
\n\
    float lightLinearIntensity = light.falloffDistance / (light.falloffDistance + (light.linearAttenuation * lightDistance)) ;\n\
    float lightQuadIntensity = sqrFalloffDistance / (sqrFalloffDistance + (light.quadraticAttenuation * sqrLightDistance)) ;\n\
    float lightIntensity = light.power * lightLinearIntensity * lightQuadIntensity ;\n\
\n\
    vec3 lightPowerColor = light.color * lightIntensity ;\n\
    vec3 returnedLighting = fragment.diffuseValue * lambertian * lightPowerColor ;\n\
    returnedLighting += fragment.specularValue * specularColor * lightPowerColor ;\n\
\n\
    return returnedLighting ;\n\
}\n\
\n\
/**\n\
 * Compute the lights contribution in a fragment shader.\n\
 * @param   viewDirection   Direction of the view.\n\
 * @param   fragment        Data on the processed fragment.\n\
 * @return  Color of the whole scene lights contribution.\n\
 */\n\
vec3 ComputeLightsContribution(\n\
    vec3 viewDirection,\n\
    FragmentData fragment\n\
) {\n\
    // Contribution of the directional light.\n\
    vec3 colorLinear = ComputeDirectionalLight(\n\
        dirLights[0],\n\
        viewDirection,\n\
        fragment\n\
    ) ;\n\
\n\
    // Contribution of point lights.\n\
    int validAmountOfPointLights = min(MAX_POINT_LIGHTS, amountPointLights) ;\n\
    for (int lightIndex = 0 ; lightIndex < validAmountOfPointLights ; lightIndex++) {\n\
        colorLinear = colorLinear +\n\
            ComputePointLight(\n\
                pointLights[lightIndex],\n\
                viewDirection,\n\
                fragment\n\
            ) ;\n\
    }\n\
\n\
    return colorLinear ;\n\
}\n\
" ;

