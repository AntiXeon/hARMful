#ifndef __ARTIFICIALINTELLIGENCE_H__
#define __ARTIFICIALINTELLIGENCE_H__

    #ifdef DEBUG_MODE
        #include "../../utils/LogGen.h"
    #endif

#include <vector>
#include <map>

#include "items.h"

#include "../../utils/Timer.h"
#include "../body/physique/Physique.h"
#include "../ColonyData.h"
#include "../Status.h"
#include "../Statistics.h"
#include "../Status.h"
#include "memory/ActionMemory.h"
#include "memory/MagicMemory.h"

/**
 * @brief Elementary elements of artificial intelligence.
 * @version 1.0 05/04/2013  The artificial intelligence becomes an independant
 *                          class from the Character one. It can be derivated
 *                          into new artificial intelligences to improve and
 *                          vary characters behaviors.
 */
class ArtificialIntelligence {
    protected:
        /** @brief Action memory to preview the behavior of the character. */
        ActionMemory* m_actionmem ;
        /** @brief Colony in which the character is member. */
        ColonyData* m_colony ;
        /** @brief Inventory with different items. */
        Inventory* m_inventory ;
        /** @brief Physique to manage body damages and equipment. */
        Physique* m_physique ;
        /** @brief Magic memory containing all learned spells. */
        MagicMemory* m_magicmem ;
        /** @brief Statistics of the character. */
        Statistics* m_statistics ;
        /** @brief Status of the character. */
        Status* m_status ;

        /** @brief The last enemy attacked by the character. */
        ArtificialIntelligence* m_lastEnemy ;

        /** @brief Timer activated while reloading the weapon. */
        Timer* m_changingWeaponTimer ;

        /** @brief To know if the character is reloading its weapon. */
        bool m_changingWeapon ;

    public:
                                                            /** CONSTRUCTORS **/
        /**
         * @brief Creation of an artificial intelligence.
         * @param action_memory Add diversity to a same artificial intelligence
         *                      class by providing different kind of judgment
         *                      about the most used action of different
         *                      characters.
         * @param physique      The object representing the aspect of the
         *                      character. It is not generated by the artificial
         *                      intelligence because it depends on the kind of
         *                      character (mammal, bird, etc).
         * @param statistics    The statistics of the character are its
         *                      strength, velocity, precision, etc.
         *                      As it depends on the type of character, it is
         *                      given to the AI constructor to allow a higher
         *                      flexibility in programming.
         */
        ArtificialIntelligence(ActionMemory* action_memory,
                               Physique* physique,
                               Statistics* statistics) ;

        /** @brief Destruction of an artificial intelligence. */
        virtual ~ArtificialIntelligence() ;
        
                                                               /** UTILITIES **/
        /**
         * @brief The life of the character is regenerated.
         * @param value     Amount of recovered HP.
         */
        void healed(short value) ;

        /**
         * @brief The character is damaged, it loses life.
         * @param value     Amount of lost HP.
         */
        void damaged(short value) ;



        /**
         * @brief Run the process of the artificial intelligence. 
         */
        virtual void run() ;


    protected:
        /**
         * @brief Method used to just manage the way the character will fight.
         *        The implementation of the AI is made here for terminal
         *        applications or some applications such as RPG turn based.
         *        If you want to implement AI for a real-time video game, you
         *        should overload this method and call specificAI() when
         *        required.
         */
        virtual void fight() ;

        /**
         * @brief Specific artificial intelligence process to choose enemy to
         * fight or ally to heal.
         */
        virtual void specificFightAI() = 0 ;


                                                                 /* SITUATION */
        /** @brief To know if another character should be healed for life. */
        virtual bool needHealHP(ArtificialIntelligence* other) = 0 ;

        /** @brief To know if another character should be healed for mana. */
        virtual bool needHealMP(ArtificialIntelligence* other) = 0 ;

        /** @brief To know if another character should be healed for status. */
        virtual bool needHealStatus(ArtificialIntelligence* other) = 0 ;

        /**
         * @brief Each kind of AI evaluates a threshold to heal characters.
         *        Some heal just before death, other are more attentive.
         */
        virtual unsigned short thresholdToHeal() = 0 ;

        /**
         * @brief The character thinks it is an excellent situation for the
         *        colony with a greater amount of allies versus enemies. The
         *        situation allows fights and low need of healing for example.
         *        Of course, the character can ignore a such situation...
         */
        virtual void excellentSituation() = 0 ;

        /**
         * @brief The character thinks it is a correct situation for the colony
         *        with an equal amount of allies and enemies. The situation
         *        should not become critical.
         *        Of course, the character can ignore a such situation...
         */
        virtual void correctSituation() = 0 ;

        /**
         * @brief The character thinks it is a critical situation for the colony
         *        as there are too much enemies, for example. The character
         *        should act to survive as long as possible and to make its team
         *        win.
         *        Of course, the character can ignore a such situation...
         */
        virtual void criticalSituation() = 0 ;

                                                                /* SELECTIONS */
        /**
         * @brief The character selects the best potion to heal HP of another
         *        character. Minimize the waste of powerful potions.
         * @return Pointer to the best potion selected.
         */
        virtual Potion* selectBestLifePotion(ArtificialIntelligence* other) ;

        /**
         * @brief The character selects the best magic to heal HP of another
         *        character. Minimize the waste of MP.
         * @return Pointer to the best magic selected.
         */
        virtual WhiteMagic* selectBestLifeMagic(ArtificialIntelligence* other) ;

        /**
         * @brief The character selects the best potion to gain MP for another
         *        character. Minimize the waste of powerful potions.
         * @return Pointer to the best potion selected.
         */
        virtual Potion* selectBestManaPotion(ArtificialIntelligence* other) ;

        /**
         * @brief The character selects the magic to protect a character
         *        increasing either its physical or its magic defense.
         */
        virtual WhiteMagic* selectBestProtectionMagic(ArtificialIntelligence* other) = 0 ;

        /**
         * @brief The character selects the magic healing from negative status
         *        effects for allies.
         */
        virtual WhiteMagic* selectBestStatusMagicForAlly(ArtificialIntelligence* other) ;

        /**
         * @brief The character selects the magic healing from positive status
         *        effects for enemies.
         */
        virtual WhiteMagic* selectBestWhiteStatusMagicForEnemy(ArtificialIntelligence* other) ;

        /**
         * @brief The character selects the magic healing from positive status
         *        effects for enemies.
         */
        virtual BlackMagic* selectBestBlackStatusMagicForEnemy(ArtificialIntelligence* other) ;


        /**
         * @brief The character selects the best weapon to use against another
         *        one.
         */
        virtual WeaponStatus* selectBestWeapon(ArtificialIntelligence* other, short& damages) ;

        /**
         * @brief The character selects the best magic to use against another
         *        one.
         */
        virtual BlackMagic* selectBestBlackMagic(ArtificialIntelligence* other, short& damages) ;


        /**
         * @brief To select the best character to heal according to the
         *        situation.
         * @return The selected character.
         */
        virtual ArtificialIntelligence* selectBestAllyToHeal() = 0 ;

        /**
         * @brief To select the best KO ally to heal. It selects the stronger
         *        ally among the KO ones.
         * @return The selected character.
         */
        virtual ArtificialIntelligence* selectBestKOAlly() ;

        /**
         * @brief The character selects the one to fight.
         * @return The selected character.
         */
        virtual ArtificialIntelligence* selectCharacterToFight() = 0 ;

        /**
         * @brief The character select the other one suffering from the most of
         *        the bad status effects (malus).
         */
        virtual ArtificialIntelligence* selectMostAffectedAlly() ;

        /**
         * @brief The character selects the enemy helped by the higher amount of
         *        status effects (bonus).
         */
        virtual ArtificialIntelligence* selectMostHelpedEnemy() ;

        /**
         * @brief The character selects the weakest one in the given list.
         * @param List of the memory addresses to the ArtificialIntelligence
         *        objects of the characters.
         * @return The weakest character or NULL pointer if the initial list
         *         is empty.
         */
        virtual ArtificialIntelligence* selectWeakestCharacter(const std::set<unsigned long>& list) ;

        /**
         * @brief The character selects the strongest one in the given list.
         * @param List of the memory addresses to the ArtificialIntelligence
         *        objects of the characters.
         * @return The strongest character or NULL pointer if the initial list
         *         is empty.
         */
        virtual ArtificialIntelligence* selectStrongestCharacter(const std::set<unsigned long>& list) ;

        /**
         * @brief The character selects one character in the given list.
         * @param List of the memory addresses to the ArtificialIntelligence
         *        objects of the characters.
         * @return One character randomly selected from the list.
         */
        ArtificialIntelligence* selectRandomCharacter(const std::set<unsigned long>& list) ;


                                                                   /* ACTIONS */
        /**
         * @brief The character tries to heal another or itself. It assess if it
         *        can use either magic or items (potions) by selecting the most
         *        appropriate solution to the situation.
         * @param other     The other character to heal.
         * @param what      Describes the way the character must be healed.
         * @return TRUE if healing succeeded, FALSE else.
         */
        virtual bool tryToHeal(ArtificialIntelligence* other, Status::HEALING what) ;

        /**
         * @brief The character heals HP of another one selecting the most
         *        efficient way to do so. It means it search the best way to
         *        avoid waste.
         * @return TRUE if the character could give HP to the other, FALSE if it
         *         not the case.
         */
        virtual bool giveHP(ArtificialIntelligence* other) ;

        /**
         * @brief The character uses a potion on another one.
         * @param other     The targeted character.
         * @param potion    The potion to use.
         */
        void usePotion(ArtificialIntelligence* other, Potion* potion) ;

        /**
         * @brief The character uses a LifePotion on another one.
         * @param other     The targeted character.
         * @param potion    The LifePotion to use.
         */
        void usePotion(ArtificialIntelligence* other, LifePotion* potion) ;

        /**
         * @brief The character uses magic to heal another one.
         * @param other     The character to heal.
         * @param magic     The magic to use to do so.
         */
        void useWhiteMagic(ArtificialIntelligence* other, WhiteMagic* magic) ;

        /**
         * @brief The character uses magic to attack another one.
         * @param other     The character to fight.
         * @param magic     The magic to use to do so.
         */
        void useBlackMagic(ArtificialIntelligence* other, BlackMagic* magic) ;

        /**
         * @brief The character uses its weapon(s) to attack another one.
         * @param other     The character to attack.
         * @param useStock  To use the stock of the weapon to shove enemies.
         */
        void useWeapon(ArtificialIntelligence* other, bool useStock) ;

        /**
         * @brief The character tests if the weapon can be effectively used.
         * @return TRUE if the weapon can be used, FALSE if not.
         */
        virtual bool testWeapon(Weapon* weapon) = 0 ;

        /**
         * @brief Select a character to fight and choose the best way to fight
         *        it.
         */
        virtual void attack(bool forcePhysical, bool forceUseStock = false) = 0 ;

        /**
         * @brief The character fights another one.
         * @param other             The character to fight.
         * @param force_physical    Force physical attacks, no magic.
         */
        virtual void fight(ArtificialIntelligence* other, bool force_physical) = 0 ;

    private:
        /**
         * @brief Both white and black magic can have status effects applied to
         *        a character. On the contrary, it can remove some effects.
         * @param other     The targeted character.
         * @param magic     The used magic.
         */
        void applyMagicStatusEffects(ArtificialIntelligence* other, Magic* magic) ;


    protected:
        /**
         * @brief Evaluate the damages made on another character by a physical
         *        attack. It considers both strength of the character and
         *        defense of the targeted one.
         * @param basis     The basis of the damages.
         */
        short evaluatePhysicalDamages(short basis, ArtificialIntelligence* other) {
            basis = (basis * (100 + (m_statistics -> getStr()))) / 100 ;
            basis -= (basis * (other -> m_statistics -> getDef())) / 100 ;

            if (basis < 1) basis = 1 ;

	        #ifdef DEBUG_MODE
	            LogGen::stream() << __FILE__ << " " << __LINE__ << ": "
	                             << "Physical damages evaluated to "
	                             << basis
	                             << " HP!" ;
                LogGen::print() ;
            #endif

            return basis ;
        }

        /**
         * @brief Evaluate the damages made on another character by a magic
         *        attack. It considers both magic strength of the character and
         *        psy defense of the targeted one.
         * @param basis     The basis of the damages.
         */
        short evaluateMagicDamages(short basis, ArtificialIntelligence* other) {
            basis = (basis * (100 + (m_statistics -> getMag()))) / 100 ;
            basis -= (basis * (other -> m_statistics -> getPsy())) / 100 ;

            if (basis < 1) basis = 1 ;

	        #ifdef DEBUG_MODE
	            LogGen::stream() << __FILE__ << " " << __LINE__ << ": "
	                             << "Magic damages evaluated to "
	                             << basis
	                             << " HP!" ;
                LogGen::print() ;
            #endif

            return basis ;
        }

        /**
         * @brief Count the total number of assaillants of the current
         *        character. It can be used to make different kind of attacks.
         * @param stop  Value to stop count.
         * @return TRUE if the amount of assaillants is lower than the threshold
         *         and FALSE else.
         */
         // @TODO improve with the distance
        bool hasTooMuchAssaillants(unsigned char threshold) ;

                                                         /** INITIALIZATIONS **/
        /**
         * @brief Initialization of the list of targeted enemies by the allies.
         *        The list contains all the enemies targeted by the allies as
         *        key and the amount of allies on each of these enemies as
         *        value.
         *        For example, <BadCharacter, 3> means that 3 allies are
         *        fighting that BadCharacter.
         *        The enemies that are not targeted are not listed here.
         *
         *        This is used to fight a same enemy as a team if required and
         *        wanted by the characters. Some characters can ignore this list
         *        and fight who they want ; some others will only fight enemies
         *        already targeted, etc...
         * @param list  Reference to the empty list of targeted enemies. The
         *              filled list is then automatically grep into the method
         *              after calling this method.
         */
        void initTargetedEnemies(std::map<ArtificialIntelligence*, unsigned short>& list) ;


                                                                 /** GETTERS **/
    public:
        /**
         * @brief Convert the value of an ArtificialIntelligence object memory
         *        address into a pointer to the ArtificialIntelligence object.
         * @param address   The address of the ArtificialIntelligence object to
         *                  retrieve.
         * @return  The pointer to the ArtificialIntelligence object.
         */
        inline static ArtificialIntelligence* convert(unsigned long address) {
            return (ArtificialIntelligence*) address ;
        }


        /**
         * @brief Get the colony of the character.
         * @return  The colony of the character.
         */
        inline ColonyData* getColony() const {
            return m_colony ;
        }

        /**
         * @brief Get the inventory of the character.
         * @return  The inventory of the character.
         */
        inline Inventory* getInventory() const {
            return m_inventory ;
        }

        /**
         * @brief Get the physique of the character.
         * @return  The physique of the character.
         */
        inline Physique* getPhysique() const {
            return m_physique ;
        }

        /**
         * @brief Get the magic memory of the character.
         * @return  The magic memory of the character.
         */
        inline MagicMemory* getMagicMemory() const {
            return m_magicmem ;
        }

        /**
         * @brief Get the statistics of the character.
         * @return  The statistics of the character.
         */
        inline Statistics* getStatistics() const {
            return m_statistics ;
        }

        /**
         * @brief Get the status of the character.
         * @return  The status of the character.
         */
        inline Status* getStatus() const {
            return m_status ;
        }


                                                                 /** SETTERS **/
        /**
         * @brief Get the colony of the character.
         * @param colony    The colony of the character.
         */
        inline void setColony(ColonyData* colony) {
            m_colony = colony ;
        }

        /**
         * @brief The character set its last enemy to null pointer
         * if it is the given one !
         */
        inline void checkLastEnemy(ArtificialIntelligence* other) {
            if (m_lastEnemy == other)
                m_lastEnemy = 0 ;
        }
} ;

#endif
