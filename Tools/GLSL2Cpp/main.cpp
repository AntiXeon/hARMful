#include <filesystem>
#include <iostream>
#include <fstream>
#include <string>
#include <locale>
#include <map>
#include <unistd.h>

using namespace std ;
namespace fs = filesystem ;

const string PathSeparator = "/" ;
const string LibName = "HOPE" ;
const string LibDirName = LibName + "ful" ;
const string ShadersDirectory = LibDirName + "/shaders" ;
const string CppPath = "scene/components/materials/" ;
const string HeaderCppDirectory = LibDirName + "/include/" + CppPath ;
const string SourceCppDirectory = LibDirName + "/src/" + CppPath ;

const string CppHeaderExtension = ".hpp" ;
const string CppSourceExtension = ".cpp" ;
const string IncludeExtension = ".inc" ;

const string VertexShaderType = "vert" ;
const string FragmentShaderType = "frag" ;
const string IncludeShaderType = "inc" ;

const std::string ModuleToCopy = "amount_lights" ;
const std::string WantedShaderFolderCopy = "modules" ;

const std::string WarningAutomaticGeneration = "// WARNING: This file is automatically generated. Any manual modification will be removed." ;

/**
 * Structure to keep together all the shader program files.
 */
struct ShaderProgramFiles {
    string directory ;

    string vertex ;
    string fragment ;
} ;

// Set the first letter of a string upper case, the other characters are lower
// case.
string firstUpLetter(const string& input) {
    string output = input ;
    output[0] = toupper(output[0]) ;

    size_t length = input.size() ;
    for (size_t index = 1 ; index < length ; index++) {
        output[index] = tolower(output[index]) ;
    }

    return output ;
}

// Set all the letters of a string upper case.
string upperCase(const string& input) {
    string output = input ;

    size_t length = input.size() ;
    for (size_t index = 0 ; index < length ; index++) {
        output[index] = toupper(output[index]) ;
    }

    return output ;
}

// Remove underscore (_) and uppercase the following character.
string removeUnderscoreChars(const string& input) {
    string output ;
    size_t length = input.size() ;
    bool upperChar = false ;

    output.reserve(length) ;

    for (size_t index = 0 ; index < length ; ++index) {
        if (input[index] != '_') {
            if (upperChar) {
                output += toupper(input[index]) ;
                upperChar = false ;
            }
            else {
                output += input[index] ;
            }
        }
        else {
            upperChar = true ;
        }
    }

    return output ;
}

// Get the list of the shader files.
void getShaderFiles(map<fs::path, ShaderProgramFiles>& shaderFiles) {
    string directory ;

    for (auto& p: fs::recursive_directory_iterator(ShadersDirectory)) {
        if (fs::is_directory(p)) {
            directory = p.path().string() ;
            continue ;
        }

        // To store in the right structure.
        string shaderName = p.path().stem().string() ;
        // To store the file path to the right shader type.
        string shaderType = p.path().extension().string().erase(0,1) ;
        // Filepath to read later.
        string shaderPath = p.path().string() ;

        std::size_t posUselessDir = directory.rfind("/materials/") ;
        std::string directoryPath = directory.substr(0, posUselessDir) ;
        directoryPath.erase(0, LibDirName.size() + 1) ;
        shaderFiles[shaderName].directory = directoryPath ;

        if (shaderType == VertexShaderType) {
            shaderFiles[shaderName].vertex = shaderPath ;
        }
        else if (shaderType == FragmentShaderType) {
            shaderFiles[shaderName].fragment = shaderPath ;
        }
        else if (shaderType == IncludeShaderType) {
            continue ;
        }
        else {
            // Unknown shader type, abord.
            cerr << "Unknown shader type: " << shaderType << ". ABORT." << endl ;
            exit(-1) ;
        }
    }
}

// Get the text content of a file.
std::string getFileContent(const std::string& filepath, const bool withNewLine) {
  std::string result ;

  ifstream input ;
  input.open(filepath) ;

  if (!input) {
        // Fail.
        std::cerr << "Unable to read the content of " << filepath << std::endl ;
        return result ;
  }

  std::string readline ;
  while (std::getline(input, readline)) {
      result += readline ;

      if (withNewLine) {
          result += "\\n\\" ;
      }

      result += "\n" ;
  }

  input.close() ;

  return result ;
}

// Write the CPP header file.
void writeHeader(const fs::path& program, const ShaderProgramFiles& files) {
    const string FullDirPath = HeaderCppDirectory + files.directory ;
    fs::create_directories(FullDirPath) ;

    const string HeaderFilename = removeUnderscoreChars(firstUpLetter(program.string())) ;
    const string HeaderDefine = "__" + LibName + "__" + upperCase(program.string()) + "_MATERIAL_SHADER_SRC__" ;

    // Open the output file.
    const string FullFilePath = FullDirPath + PathSeparator + HeaderFilename + CppHeaderExtension ;
    fstream output_file ;
    output_file.open(FullFilePath, ios_base::out) ;

    // Write in the file.
    output_file << WarningAutomaticGeneration << std::endl ;
    output_file << "#ifndef " << HeaderDefine << endl ;
    output_file << "#define " << HeaderDefine << endl ;
    output_file << endl ;
    output_file << "#include <string>" << endl ;
    output_file << endl ;

    if (!files.vertex.empty()) {
        output_file << "extern std::string " << HeaderFilename << "VertexCode ;" << endl ;
    }

    if (!files.fragment.empty()) {
        output_file << "extern std::string " << HeaderFilename << "FragmentCode ;" << endl ;
    }

    output_file << endl ;
    output_file << "#endif" << endl ;

    output_file.close() ;
}

// Write the CPP header file.
void writeSource(const fs::path& program, const ShaderProgramFiles& files) {
    const string FullDirPath = SourceCppDirectory + files.directory ;
    fs::create_directories(FullDirPath) ;

    const string SourceFilename = removeUnderscoreChars(firstUpLetter(program.string())) ;

    // Open the output file.
    const string FullFilePath = FullDirPath + PathSeparator + SourceFilename + CppSourceExtension ;
    fstream output_file ;
    output_file.open(FullFilePath, ios_base::out) ;


    // #include <header.hpp>
    const string IncludeHeaderPath = CppPath + files.directory + PathSeparator + SourceFilename + CppHeaderExtension ;
    output_file << WarningAutomaticGeneration << std::endl ;
    output_file << "#include <" << IncludeHeaderPath << ">" << endl ;
    output_file << endl ;

    if (!files.vertex.empty()) {
        output_file << "std::string " << SourceFilename << "VertexCode =" << endl ;
        output_file << "\"\\" << endl ;
        output_file << getFileContent(files.vertex, true) ;
        output_file << "\" ;" << endl ;
        output_file << endl ;
    }

    if (!files.fragment.empty()) {
        output_file << "std::string " << SourceFilename << "FragmentCode =" << endl ;
        output_file << "\"\\" << endl ;
        output_file << getFileContent(files.fragment, true) ;
        output_file << "\" ;" << endl ;
        output_file << endl ;
    }

    output_file.close() ;
}

// Write the CPP files that will contain the code of the shaders.
void writeCppFiles(const fs::path& program, const ShaderProgramFiles& files) {
    writeHeader(program, files) ;
    writeSource(program, files) ;
}


// Put the content of the include file into a GLSL module file.
void includeAsShaderModule() {
    std::string pathIncludeLights = ShadersDirectory + PathSeparator + ModuleToCopy + IncludeExtension ;

    string directory ;
    for (auto& p: fs::recursive_directory_iterator(ShadersDirectory)) {
        if (fs::is_directory(p)) {
            directory = p.path().string() ;

            if (p.path().filename().string() == WantedShaderFolderCopy) {
                fstream output_file ;
                output_file.open(directory + PathSeparator + ModuleToCopy + "." + FragmentShaderType, ios_base::out) ;
                output_file << WarningAutomaticGeneration << std::endl ;
                output_file << getFileContent(pathIncludeLights, false) ;
                output_file.close() ;
            }
        }
    }
}

// Put the content of the include file into a C++ header file.
void includeAsCppHeaders() {
    const string SourceFilename = removeUnderscoreChars(firstUpLetter(ModuleToCopy)) ;
    std::string pathIncludeLights = ShadersDirectory + PathSeparator + ModuleToCopy + IncludeExtension ;
    std::string pathHeaderIncludeLights = HeaderCppDirectory + SourceFilename + CppHeaderExtension ;

    fstream output_file ;
    output_file.open(pathHeaderIncludeLights, ios_base::out) ;
    output_file << WarningAutomaticGeneration << std::endl ;
    output_file << getFileContent(pathIncludeLights, false) ;
    output_file.close() ;
}

// Put the content of the include file into both C++ header and GLSL module files.
void convertIncludes() {
    includeAsShaderModule() ;
    includeAsCppHeaders() ;
}

// Main function.
int main() {
    convertIncludes() ;

    const string LibDirectory = "../../Libraries/" + LibDirName + "/" ;
    const string SimLinkDirectory = "./" + LibDirName ;
    symlink(LibDirectory.c_str(), SimLinkDirectory.c_str()) ;

    // Map to associate a shader program to its related files.
    map<fs::path, ShaderProgramFiles> shaderFiles ;
    getShaderFiles(shaderFiles) ;

    for (const auto& kv : shaderFiles) {
        writeCppFiles(kv.first, kv.second) ;
    }

    return 0 ;
}
